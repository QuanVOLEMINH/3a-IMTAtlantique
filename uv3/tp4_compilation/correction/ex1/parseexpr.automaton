State 0:
expression' -> . expression [ # ]
-- On IDENT shift to state 1
-- On t shift to state 2
-- On f shift to state 5
-- On expression shift to state 6
-- On e shift to state 7

State 1:
f -> IDENT . [ TIMES PLUS EOF ]
-- On TIMES reduce production f -> IDENT 
-- On PLUS reduce production f -> IDENT 
-- On EOF reduce production f -> IDENT 

State 2:
e -> t . [ PLUS EOF ]
t -> t . TIMES f [ TIMES PLUS EOF ]
-- On TIMES shift to state 3
-- On PLUS reduce production e -> t 
-- On EOF reduce production e -> t 

State 3:
t -> t TIMES . f [ TIMES PLUS EOF ]
-- On IDENT shift to state 1
-- On f shift to state 4

State 4:
t -> t TIMES f . [ TIMES PLUS EOF ]
-- On TIMES reduce production t -> t TIMES f 
-- On PLUS reduce production t -> t TIMES f 
-- On EOF reduce production t -> t TIMES f 

State 5:
t -> f . [ TIMES PLUS EOF ]
-- On TIMES reduce production t -> f 
-- On PLUS reduce production t -> f 
-- On EOF reduce production t -> f 

State 6:
expression' -> expression . [ # ]
-- On # accept expression

State 7:
e -> e . PLUS t [ PLUS EOF ]
expression -> e . EOF [ # ]
-- On PLUS shift to state 8
-- On EOF shift to state 10

State 8:
e -> e PLUS . t [ PLUS EOF ]
-- On IDENT shift to state 1
-- On t shift to state 9
-- On f shift to state 5

State 9:
e -> e PLUS t . [ PLUS EOF ]
t -> t . TIMES f [ TIMES PLUS EOF ]
-- On TIMES shift to state 3
-- On PLUS reduce production e -> e PLUS t 
-- On EOF reduce production e -> e PLUS t 

State 10:
expression -> e EOF . [ # ]
-- On # reduce production expression -> e EOF 

